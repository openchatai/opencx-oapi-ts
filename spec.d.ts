/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/actions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Import from OpenAPI file
         * @description
         *     This endpoint supports the [OpenAPI V3 Specification](https://swagger.io/specification/) (previously known as Swagger). We have introduced some new fields to the OpenAPI specification that are custom to Open. These fields are:
         *
         *     - `x-open-execute-after: string[]`
         *       This field is useful when you want to execute other operation(s) before the current operation/action. it takes an array of operation IDs. The AI will execute the operations in the order they are listed in the array.
         *
         *       ### Example
         *       Suppose you have an action with the operation ID `deleteUserCourses`. Before performing this action, you want to force the AI to list all the courses the user has and then delete them.
         *
         *       You can achieve this by adding `['listUserCourses']` to the `x-open-execute-after` field. The AI will first execute the `listUserCourses` operation and then proceed to execute the `deleteUserCourses` operation.
         *
         */
        put: operations["importActionsFromOpenAapiSpec"];
        post?: never;
        /**
         * Delete all actions
         * @description Delete all actions. This operation is safe only when you can re-import all the actions from an OpenAPI spec. Any actions created manually from the dashboard will be deleted.
         */
        delete: operations["deleteAllActions"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contacts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List contacts */
        get: operations["listContacts"];
        put?: never;
        /**
         * Create a contact
         * @description Create a new contact
         */
        post: operations["saveContact"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/contacts/{contact_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete a contact */
        delete: operations["deleteContact"];
        options?: never;
        head?: never;
        /** Update a contact */
        patch: operations["updateContact"];
        trace?: never;
    };
    "/email": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Send emails
         * @description
         *     Send emails to multiple contacts, possibly with a time delay.
         *
         *     To send emails using the API, you must first verify the domain you want to
         *     send emails from. You can add and verify custom domains in the settings.
         *
         */
        post: operations["sendEmail"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/phone/buy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create AI phone number
         * @description
         *       Buy an AI phone number. This phone number can be used to receive and make phone calls that are connected to the AI agent. For now, this API only supports US phone numbers. Email mo@open.cx for other countries.
         *
         */
        post: operations["buyPhoneNumber"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/phone": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List phone numbers */
        get: operations["listPhoneNumbers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/phone/{phone_number_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** Delete a phone number */
        delete: operations["deletePhoneNumber"];
        options?: never;
        head?: never;
        /** Update a phone number */
        patch: operations["updatePhoneNumber"];
        trace?: never;
    };
    "/phone/{phone_number_id}/call": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Make an AI phone call */
        post: operations["makeOutboundPhoneCall"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/chat/sessions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List chat sessions */
        get: operations["listChatSessions"];
        put?: never;
        /** Create a chat session */
        post: operations["createChatSession"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/chat/sessions/{session_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a chat session */
        get: operations["getChatSession"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Update a chat session */
        patch: operations["updateChatSession"];
        trace?: never;
    };
    "/chat/sessions/{session_id}/send": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Send a message */
        post: operations["sendMessage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/chat/sessions/{session_id}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List chat session history */
        get: operations["listChatHistory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sequences": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Create a sequence */
        post: operations["createSequence"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sequences/{sequence_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get a sequence */
        get: operations["getSequence"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** Update a sequence */
        patch: operations["updateSequence"];
        trace?: never;
    };
    "/sequences/{sequence_id}/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /**
         * Start a oneoff sequence
         * @description
         *     Start a oneoff sequence.
         *     - The sequence must have the `is_continuous` property set to `false`
         *     - The sequence must not have been previously canceled
         *
         */
        put: operations["startSequence"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sequences/{sequence_id}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Cancel a sequence */
        put: operations["cancelSequence"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sequences/{sequence_id}/contacts": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Add contacts to a continuous sequence
         * @description
         *     Add contacts to a continuous sequence (`is_continuous` property of the sequence must be `true`).
         *     Contacts will *not* be added to the sequence if the sequence's `filter` does not apply to the contact.
         *
         *     Any contacts added will automatically be added to contacts if they don't already exist.
         *
         */
        post: operations["addContactsToSequence"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        AddContactsToSequenceInput: {
            contacts: ({
                /** Format: uuid */
                id: string;
            } | {
                /** Format: email */
                email: string;
            } | {
                phone_number: string;
            })[];
        };
        AddContactsToSequenceOutput: {
            /** Format: uuid */
            run_id: string;
        };
        BuyPhoneNumberInput: {
            /** @description The name of the AI phone agent */
            name?: string;
            /** @description The area code of the phone number. For now, this API only supports US phone numbers, so the area code should be a 3-digit number. */
            area_code: string;
            /** @description
             *     The base prompt guides the AI's responses when interacting with customers. It
             *     serves as the foundational instruction set for the AI, defining how it
             *     should initiate conversations, handle customer inquiries, and respond to
             *     various scenarios. This prompt helps ensure that the AI provides consistent
             *     and relevant responses tailored to the specific needs of the organization and
             *     its customers.
             *      */
            base_prompt?: string;
            /** @description The phone number of the human agent to hand off the call to */
            handoff_phone_number?: string;
            /** @description The initial message to be spoken by the AI phone agent when it answers the phone call (e.g - "Hello! This is Mark from FictionalCompany. How can I help you?") */
            greeting_message?: string;
            /**
             * @description The language the AI phone agent speaks in
             * @default en
             * @enum {string}
             */
            language: "bg" | "ca" | "zh" | "zh-TW" | "cs" | "da" | "nl" | "en" | "et" | "fi" | "nl-BE" | "fr" | "de" | "de-CH" | "el" | "hi" | "hu" | "id" | "it" | "ja" | "ko" | "lv" | "lt" | "ms" | "multi" | "no" | "pl" | "pt" | "ro" | "ru" | "sk" | "es" | "sv" | "th" | "tr" | "uk" | "vi";
            /** @description Whether the AI should recognize emotions of the user on the other end of the call. If turned off, the agent will not recognize the different emotions of the user from their tone, like anger, disappointment, etc. */
            emotion_recognition?: boolean;
            /**
             * @description ID for a voice provided by 11labs. Different IDs, as well as descriptions of these voices can be found [here](https://elevenlabs.io/docs/voices/default-voices).
             * @enum {string}
             */
            elevenlabs_voice_id: "hP72SDESIJq2YuAblBqz" | "a38v0NaUbsvackET0tSL" | "UR972wNGq3zluze0LoIp" | "IOyj8WtBHdke2FjQgGAr" | "6pVydnYcVtMsrrSeUKs6" | "BafnizVJUkrZF7B8vAMB" | "7ml0LUl80q5HrlC5rH5n" | "2EUn20N7uqcXUxqGrJEF" | "dRqoXefWJMo2lbk72Ucp" | "3R4yOxfnii0AEiNj88t7" | "AcERRlWeeyUhaV8Z6nI7" | "CXlx1qNjAZaq99XYNLZl" | "ktBW0zUVLSxdQiNCm7VY" | "EOYxsIDQfFQEnzbIRe3T" | "4h05pJAlcSqTMs5KRd8X" | "H61ermx0gHYPgQYw03E4" | "fc0bJMlcn2uSFDSWPMjI" | "Yx8RZ6gdw0HEEzcwrVlS" | "4CrZuIW9am7gYAxgo2Af" | "x8udhExu0uJxUn4Tf9Az" | "sY2peC9GbHX8NCy5enOe" | "TxErUhYT25MQSG3MlH4A" | "PoPHDFYHijTq7YiSCwE3" | "tavIIPLplRB883FzWU0V" | "RFMAYURhm3MdnPIzpcwm" | "GiGOaehga8enaTnFQvb4" | "jQWvT5ZpmLknePt8F1jr" | "JjHBC66wF58p4ogebCNA" | "cfO5AAIh6JY3KjKu6QRz" | "IJOA5d06iGvU3ehQdDjg";
            /** @description The speed of the voice in which the AI agent speaks. */
            voice_speed?: number;
            /**
             * @description Specifies who speaks first in the phone call, the AI phone assistant, or, the user calling
             * @enum {string}
             */
            speaks_first?: "assistant-speaks-first" | "user-speaks-first";
            /** @description The time the AI agent waits without speech from either the AI agent or the user before ending the call */
            wait_time_before_ending_call?: number;
            /** @description The maximum number of seconds that the call will last. When the call reaches this duration, it will end. */
            call_max_duration?: number;
            /** @description This is the message that the assistant will say if it ends the call. If unspecified, it will hang up without saying anything. */
            end_call_message?: string;
            /** @description A set of messages to be said whenever there is no speach for a certain amount of time specified in `idle_timeout_seconds`, when this time is exceeded the AI agent says one of the messages specified. The different messages are seperated using commas. (e.g - "Are you still there?,Hello?,Do you need help with anything?") */
            awaiting_response_messages?: string;
            /** @description This determines the maximum number of times `awaiting_response_messages` can be spoken during the call. */
            awaiting_response_max_spoken_count?: number;
            /** @description The timeout in seconds before a message from `idleMessages` is spoken. The clock starts when the assistant finishes speaking and remains active until the user speaks. */
            awaiting_response_timeout?: number;
        };
        BuyPhoneNumberOutput: {
            /** Format: uuid */
            id: string;
            phone_number: string;
        };
        ChatMessageSender: {
            /** @enum {string} */
            type: "contact";
        } | {
            /** @enum {string} */
            type: "ai";
        } | {
            /** @enum {string} */
            type: "human_agent";
        };
        Contact: {
            /** Format: uuid */
            id: string;
            /** Format: email */
            email: string | null;
            phone_number: string | null;
            name: string | null;
            custom_data: {
                [key: string]: string;
            } | null;
        };
        ContactInput: {
            /** Format: email */
            email?: string;
            phone?: string;
            name?: string;
            custom_data?: {
                [key: string]: string;
            };
        };
        ContactsAffectedBySequenceFilter: {
            /** @enum {string} */
            type: "contacts_affected_by_sequence";
            sequence_id: string;
        };
        ContactsCreatedAtFilter: {
            /** @enum {string} */
            type: "contacts_created_at_between";
            /**
             * DateTime
             * Format: date-time
             * @description ISO 8601 date-time string
             */
            after: string | null;
            /**
             * DateTime
             * Format: date-time
             * @description ISO 8601 date-time string
             */
            before: string | null;
        };
        ContactsEmailDomainNameFilter: {
            /** @enum {string} */
            type: "contacts_email_domain_name_in";
            domain_name_in: string[];
        };
        ContactsFilter: components["schemas"]["ContactsIdsFilter"] | components["schemas"]["ContactsCreatedAtFilter"] | components["schemas"]["ContactsEmailDomainNameFilter"] | components["schemas"]["ContactsAffectedBySequenceFilter"];
        ContactsIdsFilter: {
            /** @enum {string} */
            type: "contact_id_in";
            contact_ids: string[];
        };
        /** @example {} */
        CreateChatSessionInput: {
            /** Format: uuid */
            contact_id?: string;
            /** @default {
             *       "type": "api"
             *     } */
            channel: {
                /**
                 * ChatSessionChannelType
                 * @enum {string}
                 */
                type: "web" | "web_voice" | "phone_voice" | "email" | "sms" | "whatsapp" | "api";
            };
        };
        CreateChatSessionOutput: {
            /**
             * Format: uuid
             * @description ID of the created session.
             */
            id: string;
        };
        /** @example {
         *       "steps": [
         *         {
         *           "action": {
         *             "type": "send_emails",
         *             "data": {
         *               "from_email": "no-reply@hello.opencopilot.so",
         *               "email_body": "Hello!",
         *               "email_sender_name": "OpenCX Team",
         *               "email_subject": "Welcome to OpenCX!",
         *               "email_is_transactional": false
         *             }
         *           },
         *           "delay_in_minutes": 2
         *         }
         *       ],
         *       "filter": {
         *         "or": [
         *           {
         *             "and": [
         *               {
         *                 "type": "contacts_created_at_between",
         *                 "before": "2024-09-14T15:34:49.121Z",
         *                 "after": "2024-09-14T15:34:49.121Z"
         *               }
         *             ]
         *           }
         *         ]
         *       }
         *     } */
        CreateSequenceInput: {
            /** @default New Sequence */
            name: string;
            custom_id?: string;
            /** @default true */
            is_continuous: boolean;
            /**
             * ContactsCompositeFilter
             * @description A combination of contact filters. All filters within `and` arrays must apply to a contact in order for the contact to be included. On the other hand, only one of the filters within the `or` array must apply for the contact to be included.
             */
            filter: {
                or: {
                    and: components["schemas"]["ContactsFilter"][];
                }[];
            };
            steps: {
                action: {
                    /** @enum {string} */
                    type: "send_emails";
                    data: {
                        /** Format: email */
                        from_email: string;
                        email_subject: string;
                        email_body: string;
                        email_sender_name: string;
                        email_is_transactional: boolean;
                    };
                } | {
                    /** @enum {string} */
                    type: "make_phone_calls";
                    data: Record<string, never>;
                };
                delay_in_minutes?: number;
            }[];
        };
        CreateSequenceOutput: {
            /** Format: uuid */
            id: string;
        };
        EmailRecipient: {
            /** Format: email */
            to_email: string;
            /** @description Body of the email in HTML format. */
            email_body?: string;
            email_subject?: string;
            email_sender_name?: string;
            /** @description
             *     Whether the email is transactional. If set to `false`, Open will check if the
             *     contact has [unsubscribed/opted out](./unsubscribe_api) of receiving marketing
             *     emails before sending the email. Defaults to `true`. */
            email_is_transactional?: boolean;
        };
        FileUploadDto: {
            /** Format: binary */
            file: string;
        };
        /** ChatSession */
        GetChatSessionOutput: {
            /** Format: uuid */
            id: string;
            /** @enum {string} */
            status: "open" | "closed_resolved" | "closed_unresolved";
            channel: {
                /**
                 * ChatSessionChannelType
                 * @enum {string}
                 */
                type: "web" | "web_voice" | "phone_voice" | "email" | "sms" | "whatsapp" | "api";
            };
            contact?: components["schemas"]["Contact"];
            language?: string;
            assignee_id?: string;
            /** @description Present if the conversation was handed off to a human. */
            handoff?: {
                /**
                 * HandoffSentiment
                 * @enum {string}
                 */
                sentiment?: "angry" | "neutral" | "happy";
                summary: string;
            };
            /**
             * DateTime
             * Format: date-time
             * @description ISO 8601 date-time string
             */
            created_at: string | null;
            /**
             * DateTime
             * Format: date-time
             * @description ISO 8601 date-time string
             */
            updated_at: string | null;
        };
        GetSequenceOutput: {
            name: string;
            custom_id: string | null;
            /**
             * ContactsCompositeFilter
             * @description A combination of contact filters. All filters within `and` arrays must apply to a contact in order for the contact to be included. On the other hand, only one of the filters within the `or` array must apply for the contact to be included.
             */
            filter: {
                or: {
                    and: components["schemas"]["ContactsFilter"][];
                }[];
            };
            steps: components["schemas"]["SequenceStep"][];
            is_continuous: boolean;
            started_at: string | null;
            canceled_at: string | null;
            ended_at: string | null;
        };
        /** @description Paginated response. */
        ListChatHistoryOutput: {
            items: {
                /**
                 * DateTime
                 * Format: date-time
                 * @description ISO 8601 date-time string
                 */
                created_at: string | null;
                event: {
                    /** @enum {string} */
                    type: "message";
                    sender: components["schemas"]["ChatMessageSender"];
                    content: {
                        /** @enum {string} */
                        type: "text";
                        text: string;
                    };
                } | {
                    /** @enum {string} */
                    type: "handoff";
                    integration?: {
                        /** @enum {string} */
                        type: "zendesk";
                    };
                } | {
                    /** @enum {string} */
                    type: "ai_resolved_issue";
                } | {
                    /** @enum {string} */
                    type: "human_agent_comment";
                    human_agent_id: number;
                    content: {
                        /** @enum {string} */
                        type: "text";
                        text: string;
                    };
                } | {
                    /** @enum {string} */
                    type: "human_agent_joined";
                    human_agent_id: number;
                } | {
                    /** @enum {string} */
                    type: "human_agent_takeover";
                    human_agent_id: number;
                };
            }[];
            /** @description The `cursor` for the request to get the next set of items. Null if there is no more data. */
            next: string | null;
        };
        /** @description Paginated response. */
        ListChatSessionsOutput: {
            items: {
                /** Format: uuid */
                id: string;
                /** @enum {string} */
                status: "open" | "closed_resolved" | "closed_unresolved";
                channel: {
                    /**
                     * ChatSessionChannelType
                     * @enum {string}
                     */
                    type: "web" | "web_voice" | "phone_voice" | "email" | "sms" | "whatsapp" | "api";
                };
                contact?: components["schemas"]["Contact"];
                language?: string;
                assignee_id?: string;
                /** @description Present if the conversation was handed off to a human. */
                handoff?: {
                    /**
                     * HandoffSentiment
                     * @enum {string}
                     */
                    sentiment?: "angry" | "neutral" | "happy";
                    summary: string;
                };
                /**
                 * DateTime
                 * Format: date-time
                 * @description ISO 8601 date-time string
                 */
                created_at: string | null;
                /**
                 * DateTime
                 * Format: date-time
                 * @description ISO 8601 date-time string
                 */
                updated_at: string | null;
            }[];
            /** @description The `cursor` for the request to get the next set of items. Null if there is no more data. */
            next: string | null;
        };
        /** @description Paginated response. */
        ListContactsOutput: {
            items: components["schemas"]["Contact"][];
            /** @description The `cursor` for the request to get the next set of items. Null if there is no more data. */
            next: string | null;
        };
        /** @description Paginated response. */
        ListPhoneNumbersOutput: {
            items: {
                /** Format: uuid */
                id: string;
                name: string | null;
                phone_number: string;
            }[];
            /** @description The `cursor` for the request to get the next set of items. Null if there is no more data. */
            next: string | null;
        };
        /** @example {
         *       "contact": {
         *         "phone_number": "+12345678910"
         *       }
         *     } */
        MakeOutboundPhoneCallInput: {
            contact: {
                /** Format: uuid */
                id: string;
            } | {
                phone_number: string;
            };
            options?: {
                /** @description
                 *     The base prompt guides the AI's responses when interacting with customers. It
                 *     serves as the foundational instruction set for the AI, defining how it
                 *     should initiate conversations, handle customer inquiries, and respond to
                 *     various scenarios. This prompt helps ensure that the AI provides consistent
                 *     and relevant responses tailored to the specific needs of the organization and
                 *     its customers.
                 *      */
                base_prompt?: string;
                /** @description The phone number of the human agent to hand off the call to */
                handoff_phone_number?: string;
                /** @description The initial message to be spoken by the AI phone agent when it answers the phone call (e.g - "Hello! This is Mark from FictionalCompany. How can I help you?") */
                initial_message?: string;
                /**
                 * @description The language the AI phone agent speaks in
                 * @enum {string}
                 */
                language?: "bg" | "ca" | "zh" | "zh-TW" | "cs" | "da" | "nl" | "en" | "et" | "fi" | "nl-BE" | "fr" | "de" | "de-CH" | "el" | "hi" | "hu" | "id" | "it" | "ja" | "ko" | "lv" | "lt" | "ms" | "multi" | "no" | "pl" | "pt" | "ro" | "ru" | "sk" | "es" | "sv" | "th" | "tr" | "uk" | "vi";
                /** @description Whether the AI should recognize emotions of the user on the other end of the call, if turned off, the agent will not recognize the different emotions of the user from their tone, like anger, disappointment, etc.. */
                emotion_recognition?: boolean;
                /**
                 * @description ID for a voice provided by 11labs. Different IDs, as well as descriptions of these voices can be found [here](https://elevenlabs.io/docs/voices/default-voices).
                 * @enum {string}
                 */
                elevenlabs_voice_id?: "hP72SDESIJq2YuAblBqz" | "a38v0NaUbsvackET0tSL" | "UR972wNGq3zluze0LoIp" | "IOyj8WtBHdke2FjQgGAr" | "6pVydnYcVtMsrrSeUKs6" | "BafnizVJUkrZF7B8vAMB" | "7ml0LUl80q5HrlC5rH5n" | "2EUn20N7uqcXUxqGrJEF" | "dRqoXefWJMo2lbk72Ucp" | "3R4yOxfnii0AEiNj88t7" | "AcERRlWeeyUhaV8Z6nI7" | "CXlx1qNjAZaq99XYNLZl" | "ktBW0zUVLSxdQiNCm7VY" | "EOYxsIDQfFQEnzbIRe3T" | "4h05pJAlcSqTMs5KRd8X" | "H61ermx0gHYPgQYw03E4" | "fc0bJMlcn2uSFDSWPMjI" | "Yx8RZ6gdw0HEEzcwrVlS" | "4CrZuIW9am7gYAxgo2Af" | "x8udhExu0uJxUn4Tf9Az" | "sY2peC9GbHX8NCy5enOe" | "TxErUhYT25MQSG3MlH4A" | "PoPHDFYHijTq7YiSCwE3" | "tavIIPLplRB883FzWU0V" | "RFMAYURhm3MdnPIzpcwm" | "GiGOaehga8enaTnFQvb4" | "jQWvT5ZpmLknePt8F1jr" | "JjHBC66wF58p4ogebCNA" | "cfO5AAIh6JY3KjKu6QRz" | "IJOA5d06iGvU3ehQdDjg";
                /** @description The speed of the voice in which the AI agent speaks in. */
                voice_speed?: number;
                /**
                 * @description Specifies who speaks first in the phone call, the AI phone assistant, or, the user calling
                 * @enum {string}
                 */
                speaks_first?: "assistant-speaks-first" | "user-speaks-first";
                /** @description The time the AI agent waits without speech from either the AI agent or the user, before ending the call */
                wait_time_before_ending_call?: number;
                /** @description This is the maximum number of seconds that the call will last. When the call reaches this duration, it will end. */
                call_max_duration?: number;
                /** @description A set of messages to be said whenever there is no speach for a certain amount of time specified in "awaiting_response_timeout", when this time is exceeded the AI agent says one of the messages specified. The different messages are seperated using commas. (e.g - "Are you still there?,Hello?,Do you need help with anything?") */
                awaiting_response_messages?: string;
                /** @description This determines the maximum number of times awaiting_response_messages can be spoken during the call. */
                awaiting_response_max_spoken_count?: number;
                /** @description This is the timeout in seconds before a message from idleMessages is spoken. The clock starts when the assistant finishes speaking and remains active until the user speaks. */
                awaiting_response_timeout?: number;
            };
        };
        SaveContactInput: {
            contact: components["schemas"]["ContactInput"];
        };
        SavecontactOutput: {
            /**
             * Format: uuid
             * @description The ID of the created contact.
             */
            id?: string;
        };
        SendEmailInput: {
            /**
             * Format: email
             * @description The email to send from. This email's domain name must be added and verified. Otherwise, the request will fail with a 400 status code.
             */
            from_email: string;
            /** @description
             *     Array of contacts to receive emails. The only required field is `to_email`, with the rest of the fields having fallback values that can be specified on the top level.
             *
             *     It's possible to repeat the same contact email in the array with different `delay_in_minutes` values to create a sequence of scheduled emails for that contact (e.g. for onboarding). */
            recipients: components["schemas"]["EmailRecipient"][];
            /** @description How much time (in minutes) to wait before sending the emails. */
            delay_in_minutes?: number;
            fallback_email_subject?: string;
            fallback_email_sender_name?: string;
            /** @description Fallback body of the email in HTML format. */
            fallback_email_body?: string;
        };
        SendMessageInput: {
            /** @enum {string} */
            sender: "contact";
            message: {
                /** @enum {string} */
                type: "text";
                text: string;
            };
        };
        SendMessageOutput: {
            ai_response?: {
                text: string;
                error?: {
                    message: string;
                };
            };
        };
        SequenceStep: {
            action: {
                /** @enum {string} */
                type: "send_emails";
                data: {
                    /** Format: email */
                    from_email: string;
                    email_subject: string;
                    email_body: string;
                    email_sender_name: string;
                    email_is_transactional: boolean;
                };
            } | {
                /** @enum {string} */
                type: "make_phone_calls";
                data: Record<string, never>;
            };
            delay_in_minutes?: number;
            started_at?: string;
            ended_at?: string;
        };
        UpdateChatSessionInput: {
            /** @enum {string} */
            status?: "open" | "closed_resolved" | "closed_unresolved";
        };
        UpdateContactInput: {
            contact: components["schemas"]["ContactInput"];
        };
        UpdatePhoneNumberInput: {
            /** @description The name of the AI phone agent */
            name?: string;
            /** @description
             *     The base prompt guides the AI's responses when interacting with customers. It
             *     serves as the foundational instruction set for the AI, defining how it
             *     should initiate conversations, handle customer inquiries, and respond to
             *     various scenarios. This prompt helps ensure that the AI provides consistent
             *     and relevant responses tailored to the specific needs of the organization and
             *     its customers.
             *      */
            base_prompt?: string;
            /** @description The phone number of the human agent to hand off the call to */
            handoff_phone_number?: string;
            /** @description The initial message to be spoken by the AI phone agent when it answers the phone call (e.g - "Hello! This is Mark from FictionalCompany. How can I help you?") */
            initial_message?: string;
            /**
             * @description The language the AI phone agent speaks in
             * @enum {string}
             */
            language?: "bg" | "ca" | "zh" | "zh-TW" | "cs" | "da" | "nl" | "en" | "et" | "fi" | "nl-BE" | "fr" | "de" | "de-CH" | "el" | "hi" | "hu" | "id" | "it" | "ja" | "ko" | "lv" | "lt" | "ms" | "multi" | "no" | "pl" | "pt" | "ro" | "ru" | "sk" | "es" | "sv" | "th" | "tr" | "uk" | "vi";
            /** @description Whether the AI should recognize emotions of the user on the other end of the call, if turned off, the agent will not recognize the different emotions of the user from their tone, like anger, disappointment, etc.. */
            emotion_recognition?: boolean;
            /**
             * @description ID for a voice provided by 11labs. Different IDs, as well as descriptions of these voices can be found [here](https://elevenlabs.io/docs/voices/default-voices).
             * @enum {string}
             */
            elevenlabs_voice_id: "hP72SDESIJq2YuAblBqz" | "a38v0NaUbsvackET0tSL" | "UR972wNGq3zluze0LoIp" | "IOyj8WtBHdke2FjQgGAr" | "6pVydnYcVtMsrrSeUKs6" | "BafnizVJUkrZF7B8vAMB" | "7ml0LUl80q5HrlC5rH5n" | "2EUn20N7uqcXUxqGrJEF" | "dRqoXefWJMo2lbk72Ucp" | "3R4yOxfnii0AEiNj88t7" | "AcERRlWeeyUhaV8Z6nI7" | "CXlx1qNjAZaq99XYNLZl" | "ktBW0zUVLSxdQiNCm7VY" | "EOYxsIDQfFQEnzbIRe3T" | "4h05pJAlcSqTMs5KRd8X" | "H61ermx0gHYPgQYw03E4" | "fc0bJMlcn2uSFDSWPMjI" | "Yx8RZ6gdw0HEEzcwrVlS" | "4CrZuIW9am7gYAxgo2Af" | "x8udhExu0uJxUn4Tf9Az" | "sY2peC9GbHX8NCy5enOe" | "TxErUhYT25MQSG3MlH4A" | "PoPHDFYHijTq7YiSCwE3" | "tavIIPLplRB883FzWU0V" | "RFMAYURhm3MdnPIzpcwm" | "GiGOaehga8enaTnFQvb4" | "jQWvT5ZpmLknePt8F1jr" | "JjHBC66wF58p4ogebCNA" | "cfO5AAIh6JY3KjKu6QRz" | "IJOA5d06iGvU3ehQdDjg";
            /** @description The speed of the voice in which the AI agent speaks in. */
            voice_speed?: number;
            /**
             * @description Specifies who speaks first in the phone call, the AI phone assistant, or, the user calling
             * @enum {string}
             */
            speaks_first?: "assistant-speaks-first" | "user-speaks-first";
            /** @description The time the AI agent waits without speech from either the AI agent or the user, before ending the call */
            wait_time_before_ending_call?: number;
            /** @description This is the maximum number of seconds that the call will last. When the call reaches this duration, it will end. */
            call_max_duration?: number;
            /** @description A set of messages to be said whenever there is no speach for a certain amount of time specified in "awaiting_response_timeout", when this time is exceeded the AI agent says one of the messages specified. The different messages are seperated using commas. (e.g - "Are you still there?,Hello?,Do you need help with anything?") */
            awaiting_response_messages?: string;
            /** @description This determines the maximum number of times awaiting_response_messages can be spoken during the call. */
            awaiting_response_max_spoken_count?: number;
            /** @description This is the timeout in seconds before a message from idleMessages is spoken. The clock starts when the assistant finishes speaking and remains active until the user speaks. */
            awaiting_response_timeout?: number;
        };
        /** @example {
         *       "name": "New name"
         *     } */
        UpdateSequenceInput: {
            /** @default New Sequence */
            name: string;
            custom_id?: string;
            /** @default true */
            is_continuous: boolean;
            /**
             * ContactsCompositeFilter
             * @description A combination of contact filters. All filters within `and` arrays must apply to a contact in order for the contact to be included. On the other hand, only one of the filters within the `or` array must apply for the contact to be included.
             */
            filter?: {
                or: {
                    and: components["schemas"]["ContactsFilter"][];
                }[];
            };
            steps?: {
                action: {
                    /** @enum {string} */
                    type: "send_emails";
                    data: {
                        /** Format: email */
                        from_email: string;
                        email_subject: string;
                        email_body: string;
                        email_sender_name: string;
                        email_is_transactional: boolean;
                    };
                } | {
                    /** @enum {string} */
                    type: "make_phone_calls";
                    data: Record<string, never>;
                };
                delay_in_minutes?: number;
            }[];
        };
        ErrorDto: {
            statusCode?: number;
            message?: string;
            error?: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    importActionsFromOpenAapiSpec: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The OpenAPI (Swagger) file to import actions from. Must be in JSON format. */
        requestBody: {
            content: {
                "multipart/form-data": components["schemas"]["FileUploadDto"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    deleteAllActions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    listContacts: {
        parameters: {
            query?: {
                /** @description Pagination cursor to fetch the next set of results */
                cursor?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListContactsOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    saveContact: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SaveContactInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SavecontactOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    deleteContact: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                contact_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    updateContact: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                contact_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateContactInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    sendEmail: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SendEmailInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    buyPhoneNumber: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["BuyPhoneNumberInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["BuyPhoneNumberOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    listPhoneNumbers: {
        parameters: {
            query?: {
                /** @description Pagination cursor to fetch the next set of results */
                cursor?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListPhoneNumbersOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    deletePhoneNumber: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                phone_number_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    updatePhoneNumber: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                phone_number_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdatePhoneNumberInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    makeOutboundPhoneCall: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                phone_number_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["MakeOutboundPhoneCallInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    listChatSessions: {
        parameters: {
            query?: {
                handed_off?: boolean;
                channel_type?: "web" | "web_voice" | "phone_voice" | "email" | "sms" | "whatsapp" | "api";
                status?: "open" | "closed_resolved" | "closed_unresolved";
                /** @description Pagination cursor to fetch the next set of results */
                cursor?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListChatSessionsOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    createChatSession: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateChatSessionInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateChatSessionOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    getChatSession: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                session_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetChatSessionOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    updateChatSession: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                session_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateChatSessionInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    sendMessage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                session_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["SendMessageInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SendMessageOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    listChatHistory: {
        parameters: {
            query?: {
                /** @description Pagination cursor to fetch the next set of results */
                cursor?: string;
            };
            header?: never;
            path: {
                session_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListChatHistoryOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    createSequence: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["CreateSequenceInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["CreateSequenceOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    getSequence: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID or _custom ID_ for the sequence */
                sequence_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["GetSequenceOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    updateSequence: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID or _custom ID_ for the sequence */
                sequence_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["UpdateSequenceInput"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    startSequence: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID or _custom ID_ for the sequence */
                sequence_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    cancelSequence: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID or _custom ID_ for the sequence. This can also be a _run ID_. */
                sequence_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
    addContactsToSequence: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID or _custom ID_ for the sequence. */
                sequence_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["AddContactsToSequenceInput"];
            };
        };
        responses: {
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AddContactsToSequenceOutput"];
                };
            };
            /** @description Internal Server Error */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorDto"];
                };
            };
        };
    };
}
